package com.mayankrastogi.cs441.hw2.graph

import java.io.{File, FileNotFoundException, PrintWriter}
import java.nio.file.AccessDeniedException

import com.mayankrastogi.cs441.hw2.utils.{Settings, Utils}
import com.typesafe.config.ConfigFactory
import com.typesafe.scalalogging.LazyLogging

import scala.io.Source

/**
  * Parses the output from the Map-Reduce job and generates a dot file to visualize the graph using GraphViz.
  */
object GraphGenerator extends LazyLogging {

  // Load application settings
  val settings = new Settings(ConfigFactory.load())

  /**
    * Run the generator for producing a dot file. The output directory is specified in the application settings.
    *
    * @param args First parameter denotes the input directory where the output from the map-reduce job is kept. The
    *             program will exit if one is not provided. Second parameter (Optional) can be used to specify a
    *             comma-separated list of files that should be omitted while concatenating the files.
    */
  def main(args: Array[String]): Unit = {
    logger.trace("GraphGenerator main called with arguments: " + args.mkString)

    if (args.isEmpty) {
      logger.error("Error: Please specify path to the output file of the map reduce job")
      System.exit(-1)
    }

    // If second argument is provided, exclude those comma-separated files from reading the output
    val excludedFileNames = if(args.length >= 2) {
      args(1).split(",").toList
    }
    // Otherwise, use the default excluded files list from settings
    else {
      settings.graphGenerationExcludedFileNames
    }


    generate(args.head, excludedFileNames)
  }

  /**
    * Generates the dot file after parsing output from the map-reduce job.
    *
    * @param mapReduceOutputDirectory Path to the output generated by the map-reduce job.
    */
  def generate(mapReduceOutputDirectory: String, excludedFiles: List[String]): Unit = {
    logger.trace(s"generate(mapReduceOutputDirectory: $mapReduceOutputDirectory, excludedFiles: $excludedFiles)")

    try {
      logger.info("Looking for map reduce output files in: " + mapReduceOutputDirectory)
      val fileList = Utils.getListOfFiles(mapReduceOutputDirectory, excludedFiles)

      logger.debug(s"Found ${fileList.size} files in $mapReduceOutputDirectory")
      if(fileList.isEmpty) {
        logger.error(s"No files found in the specified path: $mapReduceOutputDirectory")
        System.exit(-1)
      }

      // Concatenate file contents
      val mapReduceOutput = fileList.map(Source.fromFile(_).mkString.trim).mkString("\n")

      // Parse the map-reduce output collect information regarding all the nodes, edges and their weights
      val mapReduceOutputSummary = parseMapReduceOutput(mapReduceOutput)

      logger.info("Generating dot file...")

      // Write the dot file to disk
      writeDotFile(
        mapReduceOutputSummary,
        settings.graphOutputFilePath,
        settings.graphName,
        settings.graphLabelText,
        settings.graphColorSchemeName,
        settings.graphColorSchemeNumberOfColors,
        settings.graphLabelFontSize,
        settings.graphDimensions,
        settings.graphOverlap,
        settings.graphSeparation,
        settings.graphSplines
      )
    }
    catch {
      case e: FileNotFoundException =>
        logger.error("Could not find file at " + mapReduceOutputDirectory, e)
      case e: AccessDeniedException =>
        logger.error("Permission denied for accessing file at " + mapReduceOutputDirectory, e)
      case e: SecurityException =>
        logger.error("Permission denied for accessing file at " + mapReduceOutputDirectory, e)
      case e: Exception => {
        logger.error(s"Error ocurred while parsing files at $mapReduceOutputDirectory", e)
      }
    }
  }

  /**
    * Parses the map-reduce output and collects information regarding all the nodes, edges and their weights.
    *
    * @param outputFromMapReduce The output generated by the map-reduce job.
    * @return A data structure holding various information about the nodes, edges and their weights.
    */
  def parseMapReduceOutput(outputFromMapReduce: String): MapReduceOutputSummary = {
    logger.trace(s"parseMapReduceOutput($outputFromMapReduce)")

    // Loop through each line in the output file
    outputFromMapReduce.split("\n").foldLeft(new MapReduceOutputSummary)((summary, line) => {
      // The keys and values (w.r.t the map-reduce job) will be tab-separated
      val keyAndValue = line.trim.split("\t+")

      // Split the key by the edge indicator to determine whether the key is a node or an edge
      val nodeOrEdge = keyAndValue.head.split(settings.collaboratorsEdgeIndicator)

      // The publications will form the size or weight of the node or edge
      val publications = keyAndValue.last.toInt

      nodeOrEdge.size match {
          // If size is 1, it is a single faculty, i.e. a node in the graph
        case 1 =>
          val facultyList = summary.faculties ++ List(new Faculty(nodeOrEdge.head, publications))
          val maxPublicationsByFaculty = Math.max(summary.maxPublicationsByFaculty, publications)
          new MapReduceOutputSummary(facultyList, summary.collaborations, maxPublicationsByFaculty, summary.maxCollaborationsByFaculty)

          // If size is 2, it is a faculty pair, i.e. an edge in the graph
        case 2 =>
          val collaborationList = summary.collaborations ++ List(new Collaboration(nodeOrEdge.head, nodeOrEdge.last, publications))
          val maxCollaborationsByFaculties = Math.max(summary.maxCollaborationsByFaculty, publications)
          new MapReduceOutputSummary(summary.faculties, collaborationList, summary.maxPublicationsByFaculty, maxCollaborationsByFaculties)

        case _ => summary
      }
    })
  }

  /**
    * Generates the dot file from the parsed map-reduce output and the options provided in application settings.
    *
    * @param mapReduceOutputSummary An object that stores information about nodes, edges, and their weights.
    * @param outputPath Path to output file that will be generated by this method.
    * @param graphName Name of the graph that will be used in the dot file
    * @param graphLabel The label that will be displayed at the bottom of the generated graph.
    * @param colorScheme A pre-defined color scheme that is recognized by GraphViz
    * @param colorsInColorScheme Number of colors in the specified color scheme
    * @param labelFontSize Font-size to use for rendering the graph label
    * @param dimensions
    * @param overlap Algorithm to use for avoiding overlaps between nodes and edges
    * @param nodeSeparation Distance between adjacent nodes
    * @param splines Whether to use splines (curved lines) instead of straight lines for edges.
    */
  def writeDotFile(mapReduceOutputSummary: MapReduceOutputSummary,
                   outputPath: String,
                   graphName: String,
                   graphLabel: String,
                   colorScheme: String,
                   colorsInColorScheme: Int,
                   labelFontSize: Double,
                   dimensions: Int,
                   overlap: String,
                   nodeSeparation: Double,
                   splines: Boolean): Unit = {
    logger.trace(s"writeDotFile(mapReduceOutputSummary: $mapReduceOutputSummary, outputPath: $outputPath, graphName: $graphName, graphLabel: $graphLabel, colorScheme: $colorScheme, colorsInColorScheme: $colorsInColorScheme, labelFontSize: $labelFontSize, dimensions: $dimensions, overlap: $overlap, nodeSeparation: $nodeSeparation, splines: $splines)")

    // The maximum node size will be 1 inch of the faculty with most number of publications, individual or otherwise
    val nodeSizeScalingMultiplier = 1.0 / Math.log1p(mapReduceOutputSummary.maxPublicationsByFaculty)

    // Build the list of nodes with appropriate attributes
    val nodeOutput = mapReduceOutputSummary.faculties.foldLeft("")((builtOutput, faculty) => {

      // Since there is a huge difference between min and max number of publications, node sizes are log-transformed
      // so that bigger nodes are not too big, and smaller ones are not too small - relatively speaking
      val logOfPublications = Math.log1p(faculty.publications)
      val nodeSize = logOfPublications * nodeSizeScalingMultiplier

      // Based on the size of the node, assign a color bucket
      val color = Math.ceil(nodeSize * colorsInColorScheme).toInt

      // Build the node string
      s"""$builtOutput
         |    "${faculty.name}" [ label="${faculty.name}\\n(${faculty.publications})", width=$nodeSize, color=$color ];
         |""".stripMargin
    })

    val edgeOutput = mapReduceOutputSummary.collaborations.foldLeft("")((builtOutput, collaboration) => {

      // Thickness of edges will be based on the edge weight, i.e. number of publications, with the max thickness being
      // 4.0 and the minimum thickness being 1.0
      val edgeWeight = Math.max(4.0 * collaboration.publications.toDouble / mapReduceOutputSummary.maxCollaborationsByFaculty.toDouble, 1.0)

      // Build the edge string
      s"""$builtOutput
         |    "${collaboration.faculty1}" -- "${collaboration.faculty2}" [ label="${collaboration.publications}", weight=${collaboration.publications}, penwidth=$edgeWeight ];
         |""".stripMargin
    })

    // Build the final output string
    val dot =
      s"""graph $graphName {
         |    graph [ label="$graphLabel", fontsize=$labelFontSize, pad=0.5, overlap=$overlap, sep=$nodeSeparation, dimen=$dimensions, splines=$splines ];
         |    node [ shape=circle, fixedsize=true, style=filled, colorscheme=$colorScheme ];
         |    $nodeOutput
         |    $edgeOutput
         |}
         |""".stripMargin

    logger.debug("Generated dot file contents:\n" + dot)

    // Write the generated output to disk
    val writer = new PrintWriter(new File(outputPath))
    writer.write(dot)
    writer.close()

    logger.info("GraphViz dot file generated at: " + outputPath)
  }
}
